export default "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;        //画面解像度\nuniform vec2 textureResolution; //画像解像度\nuniform sampler2D uTexture;     //1枚目画像\nuniform sampler2D uTexture2;    //2枚目画像\nuniform sampler2D uNoise;       //ノイズ用画像\nuniform float random;           //乱数 0〜1\nuniform float progress;         //進捗 0〜2.5\nuniform float noiseScale;       //ノイズ用のscale値\nuniform float isUpward;          //上向き方向かどうか\nuniform vec3 targetColor;       //1枚目の色\nuniform vec3 targetColor2;      //2枚目の色\nvarying vec2 vUv;               //uv\n\nvoid main() {\n\n    //background cover start\n    vec2 ratio = vec2(\n        min((resolution.x / resolution.y) / (textureResolution.x / textureResolution.y), 1.0),\n        min((resolution.y / resolution.x) / (textureResolution.y / textureResolution.x), 1.0)\n    );\n\n    vec2 uv = vec2(\n        vUv.x * ratio.x + (1.0 - ratio.x) * 0.5,\n        vUv.y * ratio.y + (1.0 - ratio.y) * 0.5\n    );\n    //background cover end\n\n    //縦移動計算\n    float uvy1_upward = uv.y - progress * .1;                                                       //縦移動の移動量を追加 総移動量 → 0.25 = .1 * 2.5 (progress → 0 - 2.5)\n    float uvy1_downward = uv.y + progress * .1;                                                     //縦移動の移動量を追加 総移動量 → 0.25 = .1 * 2.5 (progress → 0 - 2.5)\n    vec2 uv2_upward = vec2(uv.x, uvy1_upward + .25);                                                //縦移動の移動量分ずらしておく 総移動量 → 0.25\n    vec2 uv2_downward = vec2(uv.x, uvy1_downward - .25);                                            //縦移動の移動量分ずらしておく 総移動量 → 0.25\n    uv.y = mix(uvy1_downward, uvy1_upward, step(1., isUpward));                                     //縦移動分を反映\n    vec2 uv2 = mix(uv2_downward, uv2_upward, step(1., isUpward));                                   //縦移動分を反映\n\n    //横軸のノイズ抽出\n    float randomX = mod(random + uv.x, 1.);                                                         //ランダムのスタート地点からuv.xを足してnoiseのx値を求める\n    vec3 noiseRGB = texture2D(uNoise, vec2(randomX * noiseScale, 0)).rgb;                           //ノイズ画像からrandomX*noiseScaleの横位置のRGBを取得\n    float noise = mix(1. - noiseRGB.r, noiseRGB.r, step(1., isUpward));                             //noiseとはつまり縦軸のズレ具合のパラメータ\n    float noise2 = 1. - noise;                                                                      //逆ノイズ。2枚目の画像の時に使う縦軸のズレ\n\n    //textures\n    vec3 baseTexRGB = texture2D(uTexture, vec2(uv.x, uv.y)).rgb;\n    vec3 baseTexRGB2 = texture2D(uTexture2, vec2(uv.x, uv2.y)).rgb;\n    vec3 texRGB = baseTexRGB;\n    vec3 texRGB2;\n    vec3 texRGB3;\n\n    //delay\n    float delay = noiseRGB.r * .5;                                                                  //delay 最大値は.5\n\n    //progress\n    float p1 = progress - delay;                                                                    //delayの分progressから引く\n    float progress1 = mix(p1, 1., step(1., p1));\n\n    float p2 = progress + noise - 1. - delay;\n//    float p2Upward = progress + noise - 1. - delay;\n//    float p2Downward = progress - noise + 1. + delay;\n\n    float progress2 = mix(p2, 1., step(1., p2));\n//    float progress2Upward = mix(p2Upward, 1., step(1., p2Upward));\n//    float progress2Downward = mix(0., p2Downward, step(p2Downward, 0.));\n//    float progress2 = mix(progress2Downward, progress2Upward, step(1., isUpward));\n\n    float progress3 = progress - 1. - delay;\n\n    float splitStart = noise;                                                                        //1枚目歪み開始地点。縦軸のズレがそのまま入る\n    float splitEnd = mix(splitStart - progress1, splitStart + progress1, step(1., isUpward));        //1枚目歪み終了地点。\n\n    //1枚目処理ここから\n    float splitStartUpward = mix(splitStart, splitStart + (1.0 + noise) * progress3, step(1.0, progress1));\n    float splitEndUpward = mix(splitEnd, splitEnd + (1.0 + noise) * progress3, step(1.0, progress1));\n    float splitStartDownward = mix(splitStart, splitStart + (1.0 - noise) * progress3, step(1.0, progress1));\n    float splitEndDownward = mix(splitEnd, splitEnd + (1.0 - noise) * progress3, step(1.0, progress1));\n    splitStart = mix(splitStartDownward, splitStartUpward, step(1.0, isUpward));\n    splitEnd = mix(splitEndDownward, splitEndUpward, step(1.0, isUpward));\n\n    //2点間の色抽出\n    vec3 startTexRGB = texture2D(uTexture, vec2(uv.x, splitStart)).rgb;\n    vec3 endTexRGB = texture2D(uTexture, vec2(uv.x, splitEnd)).rgb;\n    float mixFactor = smoothstep(splitStart, splitEnd, uv.y);\n    float stepFactorUpward = step(splitStart, uv.y) * step(uv.y, splitEnd);\n    float stepFactorDownward = step(uv.y, splitStart) * step(splitEnd, uv.y);\n    float stepFactor = mix(stepFactorDownward, stepFactorUpward, step(1.0, isUpward));\n\n    texRGB = mix(texRGB, mix(startTexRGB, endTexRGB, mixFactor), stepFactor);\n\n    //色をグラデで乗せる\n    float perUpward1 = 1. - (1. / (1. - splitStart) * (splitEnd - uv.y));\n    float perDownward1 = 1. - (1. / (splitStart) * (uv.y - splitEnd));\n    float per = mix(perDownward1, perUpward1, step(1.0, isUpward));\n    per = smoothstep(0.0, 1.0, per);\n    vec3 texRGBUpward1 = mix(texRGB, mix(texRGB, targetColor, per), step(1., splitEnd));\n    vec3 texRGBDownward1 = mix(texRGB, mix(texRGB, targetColor, per), step(splitEnd, 0.));\n    texRGB = mix(texRGBDownward1, texRGBUpward1, step(1.0, isUpward));\n    //1枚目処理ここまで\n\n    //2枚目処理ここから\n    //下からsplitStartまで\n    float p2Adjust = mix(0., progress2, step(0., progress2));               //0以下は0にする\n    float splitEnd2Upward = (splitStart + noise2) * p2Adjust;\n    float splitStart2Upward = -noise2 + (splitStart * p2Adjust);\n    float splitEnd2Downward = 1. - p2Adjust;\n    float splitStart2Downward = 1. + noise2 - (splitStart * p2Adjust);\n    float splitEnd2 = mix(splitEnd2Downward, splitEnd2Upward, step(1., isUpward));\n    float splitStart2 = mix(splitStart2Downward, splitStart2Upward, step(1., isUpward));\n\n    //2点間の色抽出\n    vec3 startTexRGB2 = texture2D(uTexture2, vec2(uv.x, splitStart2)).rgb;\n    vec3 endTexRGB2 = texture2D(uTexture, vec2(uv.x, splitEnd2)).rgb;\n    float mixFactor2 = smoothstep(splitStart2, splitEnd2, uv2.y);\n\n    texRGB2 = mix(startTexRGB2, endTexRGB2, mixFactor2);                //後で戻す\n//    texRGB2 = mix(vec3(1,0,0), vec3(0,0,1), mixFactor2);\n\n    //色をグラデで乗せる\n    float perUpward2 = 1. - (1. / (splitEnd2 - splitStart2)) * (splitEnd2 - uv2.y);\n    float perDownward2 = 1. - (1. / (splitStart2 - splitEnd2)) * (uv2.y - splitEnd2);\n    per = mix(perDownward2, perUpward2, step(1.0, isUpward));\n    per = smoothstep(0.0, 1.0, per);\n    texRGB2 = mix(targetColor2, texRGB2, per);                            //後で戻す\n\n    //splitStartから上まで\n    float splitStart3Upward = -noise2 + (1.0 + noise2) * progress3;\n    float splitStart3Downward = noise2 - (1.0 - noise2) * progress3;\n    float splitStart3 = mix(splitStart3Downward, splitStart3Upward, step(1., isUpward));\n\n    vec3 startTexRGB3 = texture2D(uTexture2, vec2(uv.x, splitStart3)).rgb;\n    vec3 endTexRGB3 = texture2D(uTexture, vec2(uv.x, splitStart)).rgb;\n    float mixFactor3 = smoothstep(splitStart3, splitStart, uv2.y);\n    texRGB3 = mix(startTexRGB3, endTexRGB3, mixFactor3);\n\n    per = 1.0 - (1.0 / (splitStart - splitStart3)) * (splitStart - uv2.y);\n    per = smoothstep(0.0, 1.0, per);\n\n    //色をグラデで乗せる\n    texRGB3 = mix(texRGB3, mix(targetColor2, texRGB3, per), step(splitStart3, 0.0));\n\n    vec3 texRGB3Upward = mix(baseTexRGB2, texRGB3, step(splitStart3, uv2.y));\n    vec3 texRGB3Downward = mix(baseTexRGB2, texRGB3, step(uv2.y, splitStart3));\n    texRGB3 = mix(texRGB3Downward, texRGB3Upward, step(1., isUpward));\n\n    texRGB2 = mix(texRGB2, texRGB3, step(0., progress3));                 //後で戻す\n\n    vec3 texRGBUpward = mix(texRGB, texRGB2, step(uv.y, splitEnd2));\n    vec3 texRGBDownward = mix(texRGB, texRGB2, step(splitEnd2, uv.y));\n    texRGB = mix(texRGBDownward, texRGBUpward, step(1., isUpward));       //後で戻す\n\n    gl_FragColor = vec4(texRGB, 1.0);                                      //後で戻す\n\n    //gl_FragColor = texture2D(uNoise, vec2(uv.x, 0));  //for debug\n}";